// 
// CompoundParserAutoGen.cs
// Contains generic implementations of CompoundParser for an arbitrary number of type parameters.
// 
// This code was autogenerated on 02/10/2021 at 10:23:05.
// Manual changes to this document will not be reflected if/when it is regenerated.
// 

using System;
using System.Collections.Generic;

namespace Cronyx.Console.Parsing
{
	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from one parameter.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from two parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from three parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from four parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2 T3]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, etc.) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="T3">The fourth parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, T3, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2], (T3) elements[3]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2), typeof(T3) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <param name="t3">The fourth parameter, whose type is <typeparamref name="T3"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2, T3 t3);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from five parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2 T3 T4]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, etc.) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="T3">The fourth parameter type in this compound type.</typeparam>
	/// <typeparam name="T4">The fifth parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, T3, T4, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2], (T3) elements[3], (T4) elements[4]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <param name="t3">The fourth parameter, whose type is <typeparamref name="T3"/></param>
		/// <param name="t4">The fifth parameter, whose type is <typeparamref name="T4"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2, T3 t3, T4 t4);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from six parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2 T3 T4 T5]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, etc.) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="T3">The fourth parameter type in this compound type.</typeparam>
	/// <typeparam name="T4">The fifth parameter type in this compound type.</typeparam>
	/// <typeparam name="T5">The sixth parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, T3, T4, T5, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2], (T3) elements[3], (T4) elements[4], (T5) elements[5]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <param name="t3">The fourth parameter, whose type is <typeparamref name="T3"/></param>
		/// <param name="t4">The fifth parameter, whose type is <typeparamref name="T4"/></param>
		/// <param name="t5">The sixth parameter, whose type is <typeparamref name="T5"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from seven parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2 T3 T4 T5 T6]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, etc.) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="T3">The fourth parameter type in this compound type.</typeparam>
	/// <typeparam name="T4">The fifth parameter type in this compound type.</typeparam>
	/// <typeparam name="T5">The sixth parameter type in this compound type.</typeparam>
	/// <typeparam name="T6">The seventh parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, T3, T4, T5, T6, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2], (T3) elements[3], (T4) elements[4], (T5) elements[5], (T6) elements[6]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <param name="t3">The fourth parameter, whose type is <typeparamref name="T3"/></param>
		/// <param name="t4">The fifth parameter, whose type is <typeparamref name="T4"/></param>
		/// <param name="t5">The sixth parameter, whose type is <typeparamref name="T5"/></param>
		/// <param name="t6">The seventh parameter, whose type is <typeparamref name="T6"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from eight parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2 T3 T4 T5 T6 T7]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, etc.) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="T3">The fourth parameter type in this compound type.</typeparam>
	/// <typeparam name="T4">The fifth parameter type in this compound type.</typeparam>
	/// <typeparam name="T5">The sixth parameter type in this compound type.</typeparam>
	/// <typeparam name="T6">The seventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T7">The eighth parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, T3, T4, T5, T6, T7, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2], (T3) elements[3], (T4) elements[4], (T5) elements[5], (T6) elements[6], (T7) elements[7]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <param name="t3">The fourth parameter, whose type is <typeparamref name="T3"/></param>
		/// <param name="t4">The fifth parameter, whose type is <typeparamref name="T4"/></param>
		/// <param name="t5">The sixth parameter, whose type is <typeparamref name="T5"/></param>
		/// <param name="t6">The seventh parameter, whose type is <typeparamref name="T6"/></param>
		/// <param name="t7">The eighth parameter, whose type is <typeparamref name="T7"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from nine parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2 T3 T4 T5 T6 T7 T8]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, etc.) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="T3">The fourth parameter type in this compound type.</typeparam>
	/// <typeparam name="T4">The fifth parameter type in this compound type.</typeparam>
	/// <typeparam name="T5">The sixth parameter type in this compound type.</typeparam>
	/// <typeparam name="T6">The seventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T7">The eighth parameter type in this compound type.</typeparam>
	/// <typeparam name="T8">The ninth parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2], (T3) elements[3], (T4) elements[4], (T5) elements[5], (T6) elements[6], (T7) elements[7], (T8) elements[8]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <param name="t3">The fourth parameter, whose type is <typeparamref name="T3"/></param>
		/// <param name="t4">The fifth parameter, whose type is <typeparamref name="T4"/></param>
		/// <param name="t5">The sixth parameter, whose type is <typeparamref name="T5"/></param>
		/// <param name="t6">The seventh parameter, whose type is <typeparamref name="T6"/></param>
		/// <param name="t7">The eighth parameter, whose type is <typeparamref name="T7"/></param>
		/// <param name="t8">The ninth parameter, whose type is <typeparamref name="T8"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from ten parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2 T3 T4 T5 T6 T7 T8 T9]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, etc.) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="T3">The fourth parameter type in this compound type.</typeparam>
	/// <typeparam name="T4">The fifth parameter type in this compound type.</typeparam>
	/// <typeparam name="T5">The sixth parameter type in this compound type.</typeparam>
	/// <typeparam name="T6">The seventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T7">The eighth parameter type in this compound type.</typeparam>
	/// <typeparam name="T8">The ninth parameter type in this compound type.</typeparam>
	/// <typeparam name="T9">The tenth parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2], (T3) elements[3], (T4) elements[4], (T5) elements[5], (T6) elements[6], (T7) elements[7], (T8) elements[8], (T9) elements[9]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <param name="t3">The fourth parameter, whose type is <typeparamref name="T3"/></param>
		/// <param name="t4">The fifth parameter, whose type is <typeparamref name="T4"/></param>
		/// <param name="t5">The sixth parameter, whose type is <typeparamref name="T5"/></param>
		/// <param name="t6">The seventh parameter, whose type is <typeparamref name="T6"/></param>
		/// <param name="t7">The eighth parameter, whose type is <typeparamref name="T7"/></param>
		/// <param name="t8">The ninth parameter, whose type is <typeparamref name="T8"/></param>
		/// <param name="t9">The tenth parameter, whose type is <typeparamref name="T9"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from eleven parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, etc.) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="T3">The fourth parameter type in this compound type.</typeparam>
	/// <typeparam name="T4">The fifth parameter type in this compound type.</typeparam>
	/// <typeparam name="T5">The sixth parameter type in this compound type.</typeparam>
	/// <typeparam name="T6">The seventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T7">The eighth parameter type in this compound type.</typeparam>
	/// <typeparam name="T8">The ninth parameter type in this compound type.</typeparam>
	/// <typeparam name="T9">The tenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T10">The eleventh parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2], (T3) elements[3], (T4) elements[4], (T5) elements[5], (T6) elements[6], (T7) elements[7], (T8) elements[8], (T9) elements[9], (T10) elements[10]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <param name="t3">The fourth parameter, whose type is <typeparamref name="T3"/></param>
		/// <param name="t4">The fifth parameter, whose type is <typeparamref name="T4"/></param>
		/// <param name="t5">The sixth parameter, whose type is <typeparamref name="T5"/></param>
		/// <param name="t6">The seventh parameter, whose type is <typeparamref name="T6"/></param>
		/// <param name="t7">The eighth parameter, whose type is <typeparamref name="T7"/></param>
		/// <param name="t8">The ninth parameter, whose type is <typeparamref name="T8"/></param>
		/// <param name="t9">The tenth parameter, whose type is <typeparamref name="T9"/></param>
		/// <param name="t10">The eleventh parameter, whose type is <typeparamref name="T10"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from twelve parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, etc.) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="T3">The fourth parameter type in this compound type.</typeparam>
	/// <typeparam name="T4">The fifth parameter type in this compound type.</typeparam>
	/// <typeparam name="T5">The sixth parameter type in this compound type.</typeparam>
	/// <typeparam name="T6">The seventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T7">The eighth parameter type in this compound type.</typeparam>
	/// <typeparam name="T8">The ninth parameter type in this compound type.</typeparam>
	/// <typeparam name="T9">The tenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T10">The eleventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T11">The twelfth parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2], (T3) elements[3], (T4) elements[4], (T5) elements[5], (T6) elements[6], (T7) elements[7], (T8) elements[8], (T9) elements[9], (T10) elements[10], (T11) elements[11]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <param name="t3">The fourth parameter, whose type is <typeparamref name="T3"/></param>
		/// <param name="t4">The fifth parameter, whose type is <typeparamref name="T4"/></param>
		/// <param name="t5">The sixth parameter, whose type is <typeparamref name="T5"/></param>
		/// <param name="t6">The seventh parameter, whose type is <typeparamref name="T6"/></param>
		/// <param name="t7">The eighth parameter, whose type is <typeparamref name="T7"/></param>
		/// <param name="t8">The ninth parameter, whose type is <typeparamref name="T8"/></param>
		/// <param name="t9">The tenth parameter, whose type is <typeparamref name="T9"/></param>
		/// <param name="t10">The eleventh parameter, whose type is <typeparamref name="T10"/></param>
		/// <param name="t11">The twelfth parameter, whose type is <typeparamref name="T11"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from thirteen parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, etc.) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="T3">The fourth parameter type in this compound type.</typeparam>
	/// <typeparam name="T4">The fifth parameter type in this compound type.</typeparam>
	/// <typeparam name="T5">The sixth parameter type in this compound type.</typeparam>
	/// <typeparam name="T6">The seventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T7">The eighth parameter type in this compound type.</typeparam>
	/// <typeparam name="T8">The ninth parameter type in this compound type.</typeparam>
	/// <typeparam name="T9">The tenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T10">The eleventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T11">The twelfth parameter type in this compound type.</typeparam>
	/// <typeparam name="T12">The thirteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2], (T3) elements[3], (T4) elements[4], (T5) elements[5], (T6) elements[6], (T7) elements[7], (T8) elements[8], (T9) elements[9], (T10) elements[10], (T11) elements[11], (T12) elements[12]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <param name="t3">The fourth parameter, whose type is <typeparamref name="T3"/></param>
		/// <param name="t4">The fifth parameter, whose type is <typeparamref name="T4"/></param>
		/// <param name="t5">The sixth parameter, whose type is <typeparamref name="T5"/></param>
		/// <param name="t6">The seventh parameter, whose type is <typeparamref name="T6"/></param>
		/// <param name="t7">The eighth parameter, whose type is <typeparamref name="T7"/></param>
		/// <param name="t8">The ninth parameter, whose type is <typeparamref name="T8"/></param>
		/// <param name="t9">The tenth parameter, whose type is <typeparamref name="T9"/></param>
		/// <param name="t10">The eleventh parameter, whose type is <typeparamref name="T10"/></param>
		/// <param name="t11">The twelfth parameter, whose type is <typeparamref name="T11"/></param>
		/// <param name="t12">The thirteenth parameter, whose type is <typeparamref name="T12"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from fourteen parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, etc.) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="T3">The fourth parameter type in this compound type.</typeparam>
	/// <typeparam name="T4">The fifth parameter type in this compound type.</typeparam>
	/// <typeparam name="T5">The sixth parameter type in this compound type.</typeparam>
	/// <typeparam name="T6">The seventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T7">The eighth parameter type in this compound type.</typeparam>
	/// <typeparam name="T8">The ninth parameter type in this compound type.</typeparam>
	/// <typeparam name="T9">The tenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T10">The eleventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T11">The twelfth parameter type in this compound type.</typeparam>
	/// <typeparam name="T12">The thirteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T13">The fourteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2], (T3) elements[3], (T4) elements[4], (T5) elements[5], (T6) elements[6], (T7) elements[7], (T8) elements[8], (T9) elements[9], (T10) elements[10], (T11) elements[11], (T12) elements[12], (T13) elements[13]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <param name="t3">The fourth parameter, whose type is <typeparamref name="T3"/></param>
		/// <param name="t4">The fifth parameter, whose type is <typeparamref name="T4"/></param>
		/// <param name="t5">The sixth parameter, whose type is <typeparamref name="T5"/></param>
		/// <param name="t6">The seventh parameter, whose type is <typeparamref name="T6"/></param>
		/// <param name="t7">The eighth parameter, whose type is <typeparamref name="T7"/></param>
		/// <param name="t8">The ninth parameter, whose type is <typeparamref name="T8"/></param>
		/// <param name="t9">The tenth parameter, whose type is <typeparamref name="T9"/></param>
		/// <param name="t10">The eleventh parameter, whose type is <typeparamref name="T10"/></param>
		/// <param name="t11">The twelfth parameter, whose type is <typeparamref name="T11"/></param>
		/// <param name="t12">The thirteenth parameter, whose type is <typeparamref name="T12"/></param>
		/// <param name="t13">The fourteenth parameter, whose type is <typeparamref name="T13"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from fifteen parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, etc.) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="T3">The fourth parameter type in this compound type.</typeparam>
	/// <typeparam name="T4">The fifth parameter type in this compound type.</typeparam>
	/// <typeparam name="T5">The sixth parameter type in this compound type.</typeparam>
	/// <typeparam name="T6">The seventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T7">The eighth parameter type in this compound type.</typeparam>
	/// <typeparam name="T8">The ninth parameter type in this compound type.</typeparam>
	/// <typeparam name="T9">The tenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T10">The eleventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T11">The twelfth parameter type in this compound type.</typeparam>
	/// <typeparam name="T12">The thirteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T13">The fourteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T14">The fifteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2], (T3) elements[3], (T4) elements[4], (T5) elements[5], (T6) elements[6], (T7) elements[7], (T8) elements[8], (T9) elements[9], (T10) elements[10], (T11) elements[11], (T12) elements[12], (T13) elements[13], (T14) elements[14]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <param name="t3">The fourth parameter, whose type is <typeparamref name="T3"/></param>
		/// <param name="t4">The fifth parameter, whose type is <typeparamref name="T4"/></param>
		/// <param name="t5">The sixth parameter, whose type is <typeparamref name="T5"/></param>
		/// <param name="t6">The seventh parameter, whose type is <typeparamref name="T6"/></param>
		/// <param name="t7">The eighth parameter, whose type is <typeparamref name="T7"/></param>
		/// <param name="t8">The ninth parameter, whose type is <typeparamref name="T8"/></param>
		/// <param name="t9">The tenth parameter, whose type is <typeparamref name="T9"/></param>
		/// <param name="t10">The eleventh parameter, whose type is <typeparamref name="T10"/></param>
		/// <param name="t11">The twelfth parameter, whose type is <typeparamref name="T11"/></param>
		/// <param name="t12">The thirteenth parameter, whose type is <typeparamref name="T12"/></param>
		/// <param name="t13">The fourteenth parameter, whose type is <typeparamref name="T13"/></param>
		/// <param name="t14">The fifteenth parameter, whose type is <typeparamref name="T14"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from sixteen parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, etc.) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="T3">The fourth parameter type in this compound type.</typeparam>
	/// <typeparam name="T4">The fifth parameter type in this compound type.</typeparam>
	/// <typeparam name="T5">The sixth parameter type in this compound type.</typeparam>
	/// <typeparam name="T6">The seventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T7">The eighth parameter type in this compound type.</typeparam>
	/// <typeparam name="T8">The ninth parameter type in this compound type.</typeparam>
	/// <typeparam name="T9">The tenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T10">The eleventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T11">The twelfth parameter type in this compound type.</typeparam>
	/// <typeparam name="T12">The thirteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T13">The fourteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T14">The fifteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T15">The sixteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2], (T3) elements[3], (T4) elements[4], (T5) elements[5], (T6) elements[6], (T7) elements[7], (T8) elements[8], (T9) elements[9], (T10) elements[10], (T11) elements[11], (T12) elements[12], (T13) elements[13], (T14) elements[14], (T15) elements[15]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <param name="t3">The fourth parameter, whose type is <typeparamref name="T3"/></param>
		/// <param name="t4">The fifth parameter, whose type is <typeparamref name="T4"/></param>
		/// <param name="t5">The sixth parameter, whose type is <typeparamref name="T5"/></param>
		/// <param name="t6">The seventh parameter, whose type is <typeparamref name="T6"/></param>
		/// <param name="t7">The eighth parameter, whose type is <typeparamref name="T7"/></param>
		/// <param name="t8">The ninth parameter, whose type is <typeparamref name="T8"/></param>
		/// <param name="t9">The tenth parameter, whose type is <typeparamref name="T9"/></param>
		/// <param name="t10">The eleventh parameter, whose type is <typeparamref name="T10"/></param>
		/// <param name="t11">The twelfth parameter, whose type is <typeparamref name="T11"/></param>
		/// <param name="t12">The thirteenth parameter, whose type is <typeparamref name="T12"/></param>
		/// <param name="t13">The fourteenth parameter, whose type is <typeparamref name="T13"/></param>
		/// <param name="t14">The fifteenth parameter, whose type is <typeparamref name="T14"/></param>
		/// <param name="t15">The sixteenth parameter, whose type is <typeparamref name="T15"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from seventeen parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, etc.) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="T3">The fourth parameter type in this compound type.</typeparam>
	/// <typeparam name="T4">The fifth parameter type in this compound type.</typeparam>
	/// <typeparam name="T5">The sixth parameter type in this compound type.</typeparam>
	/// <typeparam name="T6">The seventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T7">The eighth parameter type in this compound type.</typeparam>
	/// <typeparam name="T8">The ninth parameter type in this compound type.</typeparam>
	/// <typeparam name="T9">The tenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T10">The eleventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T11">The twelfth parameter type in this compound type.</typeparam>
	/// <typeparam name="T12">The thirteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T13">The fourteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T14">The fifteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T15">The sixteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T16">The seventeenth parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2], (T3) elements[3], (T4) elements[4], (T5) elements[5], (T6) elements[6], (T7) elements[7], (T8) elements[8], (T9) elements[9], (T10) elements[10], (T11) elements[11], (T12) elements[12], (T13) elements[13], (T14) elements[14], (T15) elements[15], (T16) elements[16]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <param name="t3">The fourth parameter, whose type is <typeparamref name="T3"/></param>
		/// <param name="t4">The fifth parameter, whose type is <typeparamref name="T4"/></param>
		/// <param name="t5">The sixth parameter, whose type is <typeparamref name="T5"/></param>
		/// <param name="t6">The seventh parameter, whose type is <typeparamref name="T6"/></param>
		/// <param name="t7">The eighth parameter, whose type is <typeparamref name="T7"/></param>
		/// <param name="t8">The ninth parameter, whose type is <typeparamref name="T8"/></param>
		/// <param name="t9">The tenth parameter, whose type is <typeparamref name="T9"/></param>
		/// <param name="t10">The eleventh parameter, whose type is <typeparamref name="T10"/></param>
		/// <param name="t11">The twelfth parameter, whose type is <typeparamref name="T11"/></param>
		/// <param name="t12">The thirteenth parameter, whose type is <typeparamref name="T12"/></param>
		/// <param name="t13">The fourteenth parameter, whose type is <typeparamref name="T13"/></param>
		/// <param name="t14">The fifteenth parameter, whose type is <typeparamref name="T14"/></param>
		/// <param name="t15">The sixteenth parameter, whose type is <typeparamref name="T15"/></param>
		/// <param name="t16">The seventeenth parameter, whose type is <typeparamref name="T16"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from eighteen parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 T17]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, etc.) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="T3">The fourth parameter type in this compound type.</typeparam>
	/// <typeparam name="T4">The fifth parameter type in this compound type.</typeparam>
	/// <typeparam name="T5">The sixth parameter type in this compound type.</typeparam>
	/// <typeparam name="T6">The seventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T7">The eighth parameter type in this compound type.</typeparam>
	/// <typeparam name="T8">The ninth parameter type in this compound type.</typeparam>
	/// <typeparam name="T9">The tenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T10">The eleventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T11">The twelfth parameter type in this compound type.</typeparam>
	/// <typeparam name="T12">The thirteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T13">The fourteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T14">The fifteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T15">The sixteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T16">The seventeenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T17">The eighteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2], (T3) elements[3], (T4) elements[4], (T5) elements[5], (T6) elements[6], (T7) elements[7], (T8) elements[8], (T9) elements[9], (T10) elements[10], (T11) elements[11], (T12) elements[12], (T13) elements[13], (T14) elements[14], (T15) elements[15], (T16) elements[16], (T17) elements[17]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <param name="t3">The fourth parameter, whose type is <typeparamref name="T3"/></param>
		/// <param name="t4">The fifth parameter, whose type is <typeparamref name="T4"/></param>
		/// <param name="t5">The sixth parameter, whose type is <typeparamref name="T5"/></param>
		/// <param name="t6">The seventh parameter, whose type is <typeparamref name="T6"/></param>
		/// <param name="t7">The eighth parameter, whose type is <typeparamref name="T7"/></param>
		/// <param name="t8">The ninth parameter, whose type is <typeparamref name="T8"/></param>
		/// <param name="t9">The tenth parameter, whose type is <typeparamref name="T9"/></param>
		/// <param name="t10">The eleventh parameter, whose type is <typeparamref name="T10"/></param>
		/// <param name="t11">The twelfth parameter, whose type is <typeparamref name="T11"/></param>
		/// <param name="t12">The thirteenth parameter, whose type is <typeparamref name="T12"/></param>
		/// <param name="t13">The fourteenth parameter, whose type is <typeparamref name="T13"/></param>
		/// <param name="t14">The fifteenth parameter, whose type is <typeparamref name="T14"/></param>
		/// <param name="t15">The sixteenth parameter, whose type is <typeparamref name="T15"/></param>
		/// <param name="t16">The seventeenth parameter, whose type is <typeparamref name="T16"/></param>
		/// <param name="t17">The eighteenth parameter, whose type is <typeparamref name="T17"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from nineteen parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 T17 T18]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, etc.) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="T3">The fourth parameter type in this compound type.</typeparam>
	/// <typeparam name="T4">The fifth parameter type in this compound type.</typeparam>
	/// <typeparam name="T5">The sixth parameter type in this compound type.</typeparam>
	/// <typeparam name="T6">The seventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T7">The eighth parameter type in this compound type.</typeparam>
	/// <typeparam name="T8">The ninth parameter type in this compound type.</typeparam>
	/// <typeparam name="T9">The tenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T10">The eleventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T11">The twelfth parameter type in this compound type.</typeparam>
	/// <typeparam name="T12">The thirteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T13">The fourteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T14">The fifteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T15">The sixteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T16">The seventeenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T17">The eighteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T18">The nineteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2], (T3) elements[3], (T4) elements[4], (T5) elements[5], (T6) elements[6], (T7) elements[7], (T8) elements[8], (T9) elements[9], (T10) elements[10], (T11) elements[11], (T12) elements[12], (T13) elements[13], (T14) elements[14], (T15) elements[15], (T16) elements[16], (T17) elements[17], (T18) elements[18]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17), typeof(T18) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <param name="t3">The fourth parameter, whose type is <typeparamref name="T3"/></param>
		/// <param name="t4">The fifth parameter, whose type is <typeparamref name="T4"/></param>
		/// <param name="t5">The sixth parameter, whose type is <typeparamref name="T5"/></param>
		/// <param name="t6">The seventh parameter, whose type is <typeparamref name="T6"/></param>
		/// <param name="t7">The eighth parameter, whose type is <typeparamref name="T7"/></param>
		/// <param name="t8">The ninth parameter, whose type is <typeparamref name="T8"/></param>
		/// <param name="t9">The tenth parameter, whose type is <typeparamref name="T9"/></param>
		/// <param name="t10">The eleventh parameter, whose type is <typeparamref name="T10"/></param>
		/// <param name="t11">The twelfth parameter, whose type is <typeparamref name="T11"/></param>
		/// <param name="t12">The thirteenth parameter, whose type is <typeparamref name="T12"/></param>
		/// <param name="t13">The fourteenth parameter, whose type is <typeparamref name="T13"/></param>
		/// <param name="t14">The fifteenth parameter, whose type is <typeparamref name="T14"/></param>
		/// <param name="t15">The sixteenth parameter, whose type is <typeparamref name="T15"/></param>
		/// <param name="t16">The seventeenth parameter, whose type is <typeparamref name="T16"/></param>
		/// <param name="t17">The eighteenth parameter, whose type is <typeparamref name="T17"/></param>
		/// <param name="t18">The nineteenth parameter, whose type is <typeparamref name="T18"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18);
	}

	/// <summary>
	/// A <see cref="ParameterParser{T}"/> that produces a <typeparamref name="TResult"/> object from twenty parameters.
	/// </summary>
	/// <remarks>
	/// <para>By default, this parser will parse an object with the following format:</para>
	/// <code>
	/// [T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 T17 T18 T19]
	/// </code>
	/// <para>and will return a <typeparamref name="TResult"/> object by passing the constituent parameters (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, etc.) to <c>GetResult</c>.</para>
	/// <para>By default, the grouping symbols used are parenthesis '()' and brackets '[],' but these can be changed by overriding <c>GroupingChars</c> in a derived class.
	/// Elements can be optionally seperated from one another using a comma ','. This seperator character can be changed by overriding <c>Seperator</c> in a derived class.</para>
	/// </remarks>
	/// <typeparam name="T0">The first parameter type in this compound type.</typeparam>
	/// <typeparam name="T1">The second parameter type in this compound type.</typeparam>
	/// <typeparam name="T2">The third parameter type in this compound type.</typeparam>
	/// <typeparam name="T3">The fourth parameter type in this compound type.</typeparam>
	/// <typeparam name="T4">The fifth parameter type in this compound type.</typeparam>
	/// <typeparam name="T5">The sixth parameter type in this compound type.</typeparam>
	/// <typeparam name="T6">The seventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T7">The eighth parameter type in this compound type.</typeparam>
	/// <typeparam name="T8">The ninth parameter type in this compound type.</typeparam>
	/// <typeparam name="T9">The tenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T10">The eleventh parameter type in this compound type.</typeparam>
	/// <typeparam name="T11">The twelfth parameter type in this compound type.</typeparam>
	/// <typeparam name="T12">The thirteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T13">The fourteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T14">The fifteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T15">The sixteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T16">The seventeenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T17">The eighteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T18">The nineteenth parameter type in this compound type.</typeparam>
	/// <typeparam name="T19">The twentieth parameter type in this compound type.</typeparam>
	/// <typeparam name="TResult">The type that this <see cref="ParameterParser{T}"/> produces.</typeparam>
	public abstract class CompoundParser<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, TResult> : CompoundParser<TResult>
	{
		protected sealed override TResult GetResult(object[] elements)
			=> GetResult((T0) elements[0], (T1) elements[1], (T2) elements[2], (T3) elements[3], (T4) elements[4], (T5) elements[5], (T6) elements[6], (T7) elements[7], (T8) elements[8], (T9) elements[9], (T10) elements[10], (T11) elements[11], (T12) elements[12], (T13) elements[13], (T14) elements[14], (T15) elements[15], (T16) elements[16], (T17) elements[17], (T18) elements[18], (T19) elements[19]);

		protected sealed override IEnumerable<Type> GetTypes()
			=> new[] { typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), typeof(T17), typeof(T18), typeof(T19) };

		/// <summary>
		/// Constructs a <typeparamref name="TResult"/> object from its constituent types.
		/// </summary>
		/// <param name="t0">The first parameter, whose type is <typeparamref name="T0"/></param>
		/// <param name="t1">The second parameter, whose type is <typeparamref name="T1"/></param>
		/// <param name="t2">The third parameter, whose type is <typeparamref name="T2"/></param>
		/// <param name="t3">The fourth parameter, whose type is <typeparamref name="T3"/></param>
		/// <param name="t4">The fifth parameter, whose type is <typeparamref name="T4"/></param>
		/// <param name="t5">The sixth parameter, whose type is <typeparamref name="T5"/></param>
		/// <param name="t6">The seventh parameter, whose type is <typeparamref name="T6"/></param>
		/// <param name="t7">The eighth parameter, whose type is <typeparamref name="T7"/></param>
		/// <param name="t8">The ninth parameter, whose type is <typeparamref name="T8"/></param>
		/// <param name="t9">The tenth parameter, whose type is <typeparamref name="T9"/></param>
		/// <param name="t10">The eleventh parameter, whose type is <typeparamref name="T10"/></param>
		/// <param name="t11">The twelfth parameter, whose type is <typeparamref name="T11"/></param>
		/// <param name="t12">The thirteenth parameter, whose type is <typeparamref name="T12"/></param>
		/// <param name="t13">The fourteenth parameter, whose type is <typeparamref name="T13"/></param>
		/// <param name="t14">The fifteenth parameter, whose type is <typeparamref name="T14"/></param>
		/// <param name="t15">The sixteenth parameter, whose type is <typeparamref name="T15"/></param>
		/// <param name="t16">The seventeenth parameter, whose type is <typeparamref name="T16"/></param>
		/// <param name="t17">The eighteenth parameter, whose type is <typeparamref name="T17"/></param>
		/// <param name="t18">The nineteenth parameter, whose type is <typeparamref name="T18"/></param>
		/// <param name="t19">The twentieth parameter, whose type is <typeparamref name="T19"/></param>
		/// <returns>A <typeparamref name="TResult"/> object.</returns>
		protected abstract TResult GetResult(T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19);
	}

}
